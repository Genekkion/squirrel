package seeds

import (
	"log"
	"sync"

	"github.com/google/uuid"
)

// The main struct used to generate, store and distribute UUIDSeeds safely
// across multiple threads. It ensures that the seeds created are all
// unique and that the V7 UUIDs created by the seeds will not collide.
type SeedStore struct {
	// Key is the V7 UUID generated by the seedBytes of the UUIDSeed,
	// based on the reference timestamp within the store.
	//
	// A nil value is used to imply that the seed has been
	// borrowed but not returned.
	store map[[16]byte]*UUIDSeed

	// Counter for the number of UUIDSeeds which have been borrowed out
	borrowCount int

	// The timestamp to be used as a reference for comparison. The theory is that
	// so long as two seeds produce different V7 UUIDs given the same seed, any
	// V7 UUID generated by the two seeds will never collide (at least until the
	// limits of the timestamp value).
	referenceTimestamp int64

	// The mutex required for multi threaded access.
	mutex sync.RWMutex
}

// The main function used to generate a store.
func NewSeedStore() *SeedStore {
	return &SeedStore{
		store:              map[[16]byte]*UUIDSeed{},
		borrowCount:        0,
		referenceTimestamp: 0,
		mutex:              sync.RWMutex{},
	}
}

// Returns the number of seeds held by this store.
func (store *SeedStore) Size() int {
	store.mutex.RLock()
	defer store.mutex.RUnlock()

	return len(store.store)
}

// Used to add seedBytes into this store. It will validate which
// seeds have already been added in previously and return the
// seeds which have successfully been inserted.
//
// Note that this function should not be used in typical conditions,
// mostly for restoring the state of the store from a backup.
func (store *SeedStore) AddFromBytes(seedBytesSlice ...[16]byte) [][16]byte {
	validSeeds := make([][16]byte, 0, len(seedBytesSlice))

	store.mutex.Lock()
	defer store.mutex.Unlock()

	for _, seedBytes := range seedBytesSlice {
		V7seedBytes := GenerateV7WithTimestamp(seedBytes, store.referenceTimestamp)
		_, exists := store.store[V7seedBytes]

		if !exists {
			store.store[V7seedBytes] = FromSeedBytes(seedBytes)
			validSeeds = append(validSeeds, seedBytes)
		}
	}
	return validSeeds
}

// Similar to AddFromBytes, but uses slice instead. Slices which do not
// have a length of 16 will be considered invalid.
func (store *SeedStore) AddFromSlices(seedSlices ...[]byte) [][16]byte {
	validSeeds := make([][16]byte, 0, len(seedSlices))

	store.mutex.Lock()
	defer store.mutex.Unlock()

	for _, seedSlice := range seedSlices {
		if len(seedSlice) != 16 { // Invalid for UUID
			continue
		}

		seedBytes := [16]byte(seedSlice)
		V7seedBytes := GenerateV7WithTimestamp(seedBytes, store.referenceTimestamp)
		_, exists := store.store[V7seedBytes]

		if !exists {
			store.store[V7seedBytes] = FromSeedBytes(seedBytes)
			validSeeds = append(validSeeds, seedBytes)
		}
	}
	return validSeeds
}

// Looks through the store and returns up to the number of seeds specified.
//
// Note that it will not generate new seeds if there are not enough seeds.
// Use GenerateNewSeeds(int) for that instead.
func (store *SeedStore) BorrowSeeds(count int) []*UUIDSeed {
	seeds := make([]*UUIDSeed, 0, count)

	store.mutex.Lock()
	defer store.mutex.Unlock()

	for seedSeed, seed := range store.store {
		if seed != nil {
			seeds = append(seeds, seed)

			// Use nil value to represent borrowed seed
			store.store[seedSeed] = nil
			store.borrowCount++
		}

		// Break out of the loop when enough seeds are found
		if len(seeds) == count {
			break
		}
	}
	return seeds
}

// Returns the UUIDSeeds previously borrowed from the store. Will ignore
// any seeds which did not belong to the store previously.
//
// The function's return value is the seeds which DID NOT belong to this store previously.
//
// Note that after returning seeds to the store, the seeds should no longer be used again
// until borrowing from the store again.
func (store *SeedStore) ReturnSeeds(seeds ...*UUIDSeed) []*UUIDSeed {
	invalidSeeds := []*UUIDSeed{}

	store.mutex.Lock()
	defer store.mutex.Unlock()

	for _, seed := range seeds {
		V7seedBytes := GenerateV7WithTimestamp(seed.seedBytes,
			store.referenceTimestamp)
		_, exists := store.store[V7seedBytes]

		if exists {
			store.store[V7seedBytes] = seed
			store.borrowCount--
		} else {
			invalidSeeds = append(invalidSeeds, seed)
		}
	}
	return invalidSeeds
}

// Generates the specified number of seeds. Is safe to call in most
// cases unless you are saturating the limit of using the seed as a
// bitmask for randomness.
func (store *SeedStore) GenerateNewSeeds(count int) {
	seedsAdded := 0
	for seedsAdded < count {
		seedBatch := make([][16]byte, 0, count-seedsAdded)

		for range count {
			seedBatch = append(seedBatch, uuid.New())
		}

		// Mutex acquired during batch seed adding.
		// This potentially improves performance since we do not try 1 by 1.
		seedsAdded += len(store.AddFromBytes(seedBatch...))
	}
}

const (
	LOG_DEBUG_TEMPLATE = "Displaying debug information of the SeedStore\n { size: %d, borrowCount: %d, availableCount: %d referenceTimestamp: %d }\n"
)

// Simple logging function which prints to stdout for quick
// debugging purposes.
func (store *SeedStore) LogDebug() {
	store.mutex.RLock()
	defer store.mutex.RUnlock()

	log.Printf(
		LOG_DEBUG_TEMPLATE,
		len(store.store),
		store.borrowCount,
		len(store.store)-store.borrowCount,
		store.referenceTimestamp,
	)
}
